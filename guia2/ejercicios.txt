%ejercicio1 Guia 2
concatenar([],L,L).

concatenar([X|Xs],L,[X|R]) :-
    			concatenar(Xs,L,R).

prefijo([],_L).
prefijo([X|Xs],[X|Ys]) :-
    	 	prefijo(Xs,Ys).

sufijo(L,L).
sufijo([X|Xs],[_Y|Ys]) :-
    		sufijo([X|Xs],Ys).

sublista([],_L).
sublista([X|Xs],[Y|Ys]) :-
    		sufijo(Sufijo,[Y|Ys]),
    		prefijo([X|Xs], Sufijo).

ultimo(X,[X]).
ultimo(X, [_Y|Ys]) :-
    	ultimo(X,Ys).

miembro(Elemento,[Elemento|_]).
miembro(Elemento,[_Y|Ys]) :-
    	miembro(Elemento,Ys).

adyacente(X,Y,[X,Y|_]).
adyacente(X,Y,[_Z|Zs]) :-
    	adyacente(X,Y,Zs).

selecciona([E|Es],E,Es).
selecciona([X|Xs], Elemento, [Y|Ys]) :-
    		append([X],S,[Y|Ys]),
    		selecciona(Xs,Elemento,S),!.

ultimaPos(E,[E|[]]).
ultimaPos(E,[_X|Xs]) :-
    		ultimaPos(E,Xs).



reverse([],[]).
reverse([X|Xs],Zs) :-
    		append(R,[X],Zs),
    		reverse(Xs,R).
/*
longitud([],0).
longitud([_X|Xs],L) :-
    	longitud(Xs,R),
    	L is R+1.
*/

 %permuta(Lista, Permuta): evalua verdadero 
 %si Permuta corresponde a una permutacion de Lista. 

permuta([],[]).
permuta([X|Xs],[Y|Ys]) :-
    		selecciona([Y|Ys],X,L),
    		permuta(Xs,L).


%----------------------------------------------------------------

 % Ejercicio 2
 %Miembro en listas anidadas

 %Definir el predicado ocurre(Elemento, Lista) que debera evaluar verdadero cuando Elemento ocurra en cualquier lugar de Lista. 
 %Tener en cuenta que Lista puede contener listas(cualquier nivel de anidamiento).

 %member(a,[a,b,c])
lista([]).
lista([_X|Xs]) :-
    	lista(Xs).

ocurre(E,[E|_]).
ocurre(Elemento,[X|_Xs]):-
    	lista(X),
    	ocurre(Elemento,X),!.

ocurre(Elemento,[_X|Xs]):-
    	ocurre(Elemento,Xs).


%----------------------------------------------------------------

% Ejercicio 3
%  Lista de elementos atomicos

listaAtomos([],[]).
listaAtomos([X|Xs],[Y|Ys]) :-
    		not(lista(X)),
    		Y = X,
    		listaAtomos(Xs,Ys).

listaAtomos([X|Xs],[Y|Ys]) :-
    		lista(X),
    		listaAtomos(X,R),
    		listaAtomos(Xs,Rs),
    		append(R,Rs,[Y|Ys]).

%----------------------------------------------------------------


%----------------------------------------------------------------

% Ejercicio 4
%  Subsecuencia(Secuencia,Sub)
iguales(X,X).
subSecuencia([],[]).
subSecuencia(X,[]) :- lista(X).
subSecuencia([X|Xs],[X|Ys]) :-
    	subSecuencia(Xs,Ys).
subSecuencia([X|Xs],[Y|Ys]) :-
    	not(iguales(X,Y)),
    	subSecuencia(Xs,[Y|Ys]).

%----------------------------------------------------------------

%----------------------------------------------------------------

% Ejercicio 5
%  Predicados con ARBOLES BINARIOS
% a) arbolBinario(Arbol): 
% 	 evalua verdadero si el argumento es un arbol binario

arbolBinario(nil).
arbolBinario(arbol(_Raiz,AI,AD)) :-
    	arbolBinario(AI),
    	arbolBinario(AD).

% b) miembroArbol(Valor, Arbol): 
% evalua verdadero si Valor se encuentra almacenado en un nodo
miembroArbol(Valor,arbol(Valor,_,_)).
miembroArbol(Valor,arbol(_Raiz,AI,_AD)) :-
    		miembroArbol(Valor,AI).
miembroArbol(Valor,arbol(_Raiz,_AI,AD)) :-
    		miembroArbol(Valor,AD).

% c) listaHojas(Arbol, Hojas): 
% se satisface si la lista Hojas contiene
% los valores almacenados en las hojas de Arbol.

listaHojas(arbol(Raiz,nil,nil),[Raiz]).

listaHojas(arbol(_Raiz,AI,AD),[X|Xs]) :-
    		listaHojas(AI,LI),
    		listaHojas(AD,LD),
    		append(LI,LD,[X|Xs]).

listaHojas(arbol(_Raiz,AI,nil), Lista) :-
    		listaHojas(AI,Lista).

listaHojas(arbol(_Raiz,nil,AD), Lista) :-
    		listaHojas(AD,Lista).


% d) preorden(Arbol, Lista): 
% evalua verdadero si el segundo argumento es una lista que contiene
% los valores de los nodos del arbol binario Arbol segun recorrido preorden.
%[RAIZ AI AD]
preorden(arbol(Raiz,nil,nil),[Raiz]).
preorden(arbol(Raiz,AI,nil),[X|Xs]) :-
    		preorden(AI,LI),	
    		append([Raiz],LI,[X|Xs]).
preorden(arbol(Raiz,nil,AD),[X|Xs]) :-
    		preorden(AD,LD),
    		append([Raiz],LD,[X|Xs]).
preorden(arbol(Raiz,AI,AD),[X|Xs])	:-
    		preorden(AI,LI),
    		append([Raiz],LI,RLI),
    		preorden(AD,LD),
    		append(RLI,LD,[X|Xs]).

% e) inorden(Arbol, Lista): ıdem anterior pero segun recorrido inorden.
%[AI RAIZ AD]
inorden(arbol(Raiz,nil,nil),[Raiz]).
inorden(arbol(Raiz,AI,nil),[X|Xs]) :-
    		inorden(AI,LI),	
    		append(LI,[Raiz],[X|Xs]).
inorden(arbol(Raiz,nil,AD),[X|Xs]) :-
    		inorden(AD,LD),
    		append([Raiz],LD,[X|Xs]).
inorden(arbol(Raiz,AI,AD),[X|Xs])	:-
    		inorden(AI,LI),
    		append(LI,[Raiz],LIR),
    		inorden(AD,LD),
    		append(LIR,LD,[X|Xs]).

% f) posorden(Arbol, Lista): ıdem anterior pero segun recorrido posorden
%[AI AD RAIZ]
posorden(arbol(Raiz,nil,nil),[Raiz]).
posorden(arbol(Raiz,AI,nil),[X|Xs]) :-
    		posorden(AI,LI),	
    		append(LI,[Raiz],[X|Xs]).
posorden(arbol(Raiz,nil,AD),[X|Xs]) :-
    		posorden(AD,LD),
    		append(LD,[Raiz],[X|Xs]).
posorden(arbol(Raiz,AI,AD),[X|Xs])	:-
    		posorden(AI,LI),
    		posorden(AD,LD),
    		append(LI,LD,LILD),
    		append(LILD,[Raiz],[X|Xs]).

%CONSULTA PARA PROBAR ESTOS RECORRIDOS:
/*
 posorden( arbol(1,
 arbol(2, nil, arbol(4, nil, nil)),
 arbol(3, arbol(5, arbol(7, nil, nil), nil),
 arbol(6, nil, nil))),LISTA),

 posorden(arbol(9, 
            arbol(2,arbol(3,nil,nil),arbol(4,arbol(5,nil,nil),arbol(7,nil,nil))),
            arbol(8,arbol(9,nil,nil),arbol(11,nil,nil))
                 ), Resultado).
*/


%----------------------------------------------------------------


%----------------------------------------------------------------

%   PARTE  II
% Ejercicio 6
% Predicados relacionales y/o aritméticos con listas

%  a) longitud(Lista, N): eval´ua verdadero si N es la longitud de Lista.

longitud([],0).
longitud([_X|Xs],L) :-
    longitud(Xs,Ls),
    L is (1 + Ls).


%b) maximo(Lista, Max): se satisface si Max es el valor maximo de Lista.

maximo([X],X).
maximo([X|Xs],Maximo) :-
    	maximo(Xs,Ms),
    	X >= Ms,
    	Maximo = X.
maximo([X|Xs],Maximo) :-
    	maximo(Xs,Ms),
    	X < Ms,
    	Maximo = Ms.

% d) enesimo(Lista, N, Elemento):
% evalua verdadero si Elemento se encuentra en la posicion N de Lista
enesimo([X|_Xs],1,X).
enesimo([_X|Xs],N,Elem) :-
    	enesimo(Xs,Ns,Elem),
    	N is Ns+1.

% e) sumaLista(Lista, Suma): 
% se satisface si Suma es la suma de los elementos de Lista
sumaLista([],0).
sumaLista([X|Xs],S) :-
    	sumaLista(Xs,Ss),
    	S is (Ss + X).

% f) sinDuplicados(Lista, LSinDup):
% se satisface si LSinDup unifica
% con la lista resultante de quitar los elementos repetidos de Lista.

sinDuplicados([],[]).
sinDuplicados([X|Xs],R) :- 
    	sinDuplicadosAux([X|Xs],[],R).

sinDuplicadosAux([],Acc,R) :- 
    	reverse(Acc,R).
sinDuplicadosAux([X|Xs],Acc,R) :-
    	member(X,Acc),
    	sinDuplicadosAux(Xs,Acc,R).
    	
sinDuplicadosAux([X|Xs], Acc, R) :-
    	not(member(X, Acc)),
    	sinDuplicadosAux(Xs, [X|Acc], R).
    
    
    

%----------------------------------------------------------------

